# Java匿名内部类知识总结

匿名内部类（Anonymous Inner Class）是Java中一种没有名字的内部类，通常用于简化代码，实现接口或继承类并直接创建实例。

## 基本概念

1. **定义方式**：在创建对象的同时定义类，没有显式的类名
2. **使用场景**：通常用于只需要使用一次的类实现
3. **语法特点**：结合了类的定义和实例化

## 语法结构

```java
// 继承类形式
new SuperClass() {
    // 匿名内部类成员定义
    @Override
    public void method() {
        // 实现代码
    }
};

// 实现接口形式
new Interface() {
    @Override
    public void method() {
        // 实现代码
    }
};
```

## 主要特点

1. **无类名**：没有显式的类名，编译器会为其生成一个名称（如OuterClass$1）
2. **即时创建**：定义后立即创建实例，不能重复使用
3. **访问权限**：
    - 可以访问外部类的所有成员
    - 可以访问final或effectively final的局部变量（Java 8+）

4. **限制**：
    - 不能定义构造方法（但可以有实例初始化块）
    - 不能是抽象类
    - 不能定义静态成员（常量除外）

## 常见使用场景

1. **事件监听器**（GUI编程中最常见）：

```java
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Button clicked!");
    }
});
```

2. **线程实现**：

```java
new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Thread running");
    }
}).start();
```

3. **Comparator实现**：

```java
Collections.sort(list, new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.length() - s2.length();
    }
});
```

## 与Lambda表达式的关系

1. 在Java 8+中，许多匿名内部类可以被Lambda表达式替代
2. 但匿名内部类更强大，可以：
    - 实现多个方法的接口
    - 继承类并重写方法
    - 添加额外字段和方法

## 注意事项

1. **内存泄漏风险**：
    - 匿名内部类隐式持有外部类引用
    - 长时间存在的匿名内部类可能导致外部类无法被GC回收

2. **可读性**：
    - 复杂逻辑的匿名内部类会降低代码可读性
    - 当逻辑复杂时，应考虑使用命名内部类或独立类

3. **变量访问限制**：
    - 只能访问final或effectively final的局部变量
    - 在Java 8之前必须显式声明为final

## 示例：访问外部变量

```java
public void test() {
    final int x = 10; // Java 7及以前必须显式final
    int y = 20;       // Java 8+ effectively final
    
    Runnable r = new Runnable() {
        @Override
        public void run() {
            System.out.println(x + y); // 可以访问
            // y = 30; // 错误：不能修改effectively final变量
        }
    };
    new Thread(r).start();
}
```

匿名内部类是Java中一种简洁的编码方式，特别适合创建只需使用一次的简单实现类，但随着Lambda表达式的引入，其使用场景有所减少，但在需要实现多方法接口或继承类时仍然非常有用。