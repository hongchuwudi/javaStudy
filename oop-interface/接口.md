# Java接口全面解析

接口(Interface)是Java语言的核心特性之一，它定义了一组抽象规范，是实现多态和抽象编程的重要工具。随着Java版本的演进，接口的功能不断丰富和增强。

## 一、接口基础概念

### 1. 接口定义

```java
public interface Vehicle {
    // 常量（默认 public static final）
    int MAX_SPEED = 120;
    
    // 抽象方法（默认 public abstract）
    void start();
    void stop();
}
```

### 2. 基本特性

- **完全抽象类型**（Java 8前）
- **不能实例化**
- **多继承机制**：一个类可实现多个接口
- **契约式编程**：定义行为规范

## 二、接口的演进历程

| Java版本   | 接口新特性              |
|----------|--------------------|
| Java 7-  | 只包含常量和抽象方法         |
| Java 8   | 默认方法(default)、静态方法 |
| Java 9   | 私有方法(private)      |
| Java 11+ | 无新特性，持续优化          |

## 三、接口成员详解

### 1. 抽象方法

```java
void move();  // 默认public abstract
```

### 2. 默认方法(Java 8+)

```java
default void log(String info) {
    System.out.println("日志: " + info);
}
```

**特点**：

- 提供默认实现
- 解决接口演化问题
- 可被实现类重写

### 3. 静态方法(Java 8+)

```java
static boolean isElectric(int voltage) {
    return voltage > 220;
}
```

**特点**：

- 接口直接调用（`Vehicle.isElectric(380)`）
- 不可被实现类继承或重写

### 4. 私有方法(Java 9+)

```java
private void internalProcess() {
    // 辅助方法
}
```

**用途**：

- 提取公共代码
- 隐藏实现细节

### 5. 常量字段

```java
String TYPE = "Transport";  // 默认public static final
```

## 四、接口继承与实现

### 1. 接口继承接口

```java
interface ElectricVehicle extends Vehicle {
    void charge();
}
```

### 2. 类实现接口

```java
class Car implements Vehicle, ElectricVehicle {
    @Override
    public void start() { /* 实现 */ }
    
    @Override
    public void stop() { /* 实现 */ }
    
    @Override
    public void charge() { /* 实现 */ }
}
```

### 3. 默认方法冲突解决规则

1. **类优先**：类中的方法优先于接口默认方法
2. **接口冲突**：必须显式指定使用哪个接口的默认方法

```java
interface A { default void foo() {} }
interface B { default void foo() {} }

class C implements A, B {
    @Override
    public void foo() {
        A.super.foo();  // 显式选择A接口的实现
    }
}
```

## 五、接口的高级特性

### 1. 函数式接口(Java 8+)

```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
    
    // 只能有一个抽象方法
    // 但可以有多个默认/静态方法
}
```

### 2. 标记接口

```java
interface Serializable {}  // 无方法的标记接口
```

### 3. 接口与多继承

```java
class HybridCar extends Car implements ElectricVehicle, GasolineVehicle {
    // 实现所有接口方法
}
```

## 六、接口与抽象类的比较

| 特性       | 接口          | 抽象类   |
|----------|-------------|-------|
| **实例化**  | 不能          | 不能    |
| **方法类型** | 抽象/默认/静态/私有 | 抽象/具体 |
| **变量**   | 只常量         | 任意变量  |
| **继承**   | 多继承         | 单继承   |
| **构造器**  | 无           | 有     |
| **设计目的** | 定义契约        | 代码复用  |

## 七、接口的设计模式应用

### 1. 策略模式

```java
interface SortingStrategy {
    void sort(int[] data);
}

class QuickSort implements SortingStrategy {
    public void sort(int[] data) { /* 实现 */ }
}
```

### 2. 工厂模式

```java
interface Logger {
    void log(String message);
    
    static Logger getLogger(String type) {
        return type.equals("file") ? new FileLogger() : new ConsoleLogger();
    }
}
```

### 3. 观察者模式

```java
interface Observer {
    void update(String event);
}
```

## 八、最佳实践

1. **命名规范**：
    - 形容词接口：`-able`后缀（`Runnable`, `Serializable`）
    - 名词接口：直接描述能力（`List`, `Map`）

2. **设计原则**：
    - 接口隔离原则（ISP）
    - 优先使用接口而非抽象类

3. **版本兼容**：
    - 新增方法优先使用默认方法
    - 避免破坏现有实现

4. **文档要求**：
    - 明确接口契约
    - 说明默认方法的行为

## 九、常见面试问题

1. **Java 8为什么引入默认方法？**
    - 解决接口演化问题
    - 支持函数式编程

2. **接口可以有构造器吗？**
    - 不能，接口不能被实例化

3. **什么时候用抽象类？什么时候用接口？**
    - 需要多继承或定义契约：接口
    - 需要共享代码或状态：抽象类

4. **默认方法会破坏多继承吗？**
    - 不会，有明确的冲突解决规则

5. **函数式接口能有多少个抽象方法？**
    - 严格一个（@FunctionalInterface注解强制检查）

接口是Java实现抽象和多态的核心机制，随着版本演进功能不断增强，合理使用接口可以设计出灵活、可扩展的系统架构。