# Java单例模式全面总结

单例模式(Singleton Pattern)是Java中最常用的设计模式之一，确保一个类只有一个实例，并提供全局访问点。以下是Java单例模式的完整知识总结。

## 一、单例模式的核心要点

1. **核心特征**：
    - 私有构造方法（防止外部实例化）
    - 静态私有实例变量
    - 静态公有获取实例方法

2. **实现目标**：
    - 控制实例数目（仅一个）
    - 全局访问点
    - 延迟初始化（可选）

## 二、单例模式的多种实现方式

### 1. 饿汉式（Eager Initialization）

- **特点**：类加载时就初始化实例
- **优点**：线程安全，实现简单
- **缺点**：可能造成资源浪费（如果从未使用）

```java
public class EagerSingleton {
    private static final EagerSingleton INSTANCE = new EagerSingleton();
    
    private EagerSingleton() {}
    
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}
```

### 2. 懒汉式（Lazy Initialization）

- **特点**：首次使用时才创建实例
- **基础版问题**：线程不安全

```java
public class LazySingleton {
    private static LazySingleton instance;
    
    private LazySingleton() {}
    
    // 线程不安全版本
    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

### 3. 同步方法懒汉式（Thread-Safe）

- **改进**：添加synchronized保证线程安全
- **缺点**：性能较差（每次获取实例都要同步）

```java
public synchronized static LazySingleton getInstance() {
    if (instance == null) {
        instance = new LazySingleton();
    }
    return instance;
}
```

### 4. 双重检查锁（Double-Checked Locking）

- **特点**：减少同步开销
- **volatile关键字**：防止指令重排序

```java
public class DCLSingleton {
    private static volatile DCLSingleton instance;
    
    private DCLSingleton() {}
    
    public static DCLSingleton getInstance() {
        if (instance == null) {                     // 第一次检查
            synchronized (DCLSingleton.class) {      // 加锁
                if (instance == null) {             // 第二次检查
                    instance = new DCLSingleton(); // 初始化
                }
            }
        }
        return instance;
    }
}
```

### 5. 静态内部类（Holder Pattern）

- **特点**：利用类加载机制保证线程安全
- **优点**：延迟加载且线程安全

```java
public class HolderSingleton {
    private HolderSingleton() {}
    
    private static class SingletonHolder {
        private static final HolderSingleton INSTANCE = new HolderSingleton();
    }
    
    public static HolderSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

### 6. 枚举单例（Enum Singleton）

- **特点**：Java 1.5+最佳实现方式
- **优点**：防止反射攻击，自动序列化安全

```java
public enum EnumSingleton {
    INSTANCE;
    
    public void doSomething() {
        // 业务方法
    }
}
```

## 三、单例模式的高级主题

### 1. 防止反射攻击

- 普通单例可能被反射破坏，枚举单例天然防护

```java
// 防止反射攻击的改进版
public class ReflectionSafeSingleton {
    private static volatile ReflectionSafeSingleton instance;
    
    private ReflectionSafeSingleton() {
        if (instance != null) {
            throw new IllegalStateException("Already initialized");
        }
    }
    // ...双重检查锁实现
}
```

### 2. 序列化与反序列化安全

- 需要实现`readResolve()`方法防止反序列化创建新实例

```java
protected Object readResolve() {
    return getInstance();
}
```

### 3. 单例模式在容器环境中的问题

- 每个类加载器可能创建自己的单例实例
- 解决方案：使用容器提供的单例管理机制

## 四、单例模式的最佳实践

1. **实现选择建议**：
    - Java 5+环境优先使用**枚举单例**
    - 需要延迟加载使用**静态内部类**方式
    - 早期版本考虑**双重检查锁**

2. **使用场景**：
    - 配置信息类
    - 线程池、连接池
    - 缓存系统
    - 日志系统
    - 设备驱动对象

3. **注意事项**：
    - 避免滥用单例（会导致代码耦合度高）
    - 考虑单元测试的困难（单例难以mock）
    - 多线程环境下确保线程安全
    - 在分布式系统中，单例仅对单个JVM有效

## 五、单例模式的优缺点

### 优点：

1. 严格控制实例数量
2. 全局访问点方便管理
3. 节省系统资源（特别是重量级对象）

### 缺点：

1. 违反单一职责原则（同时控制生命周期和业务逻辑）
2. 难以扩展（通常不允许派生）
3. 隐藏类之间的依赖关系
4. 对单元测试不友好

## 六、常见面试问题

1. **为什么枚举单例是最佳实现？**
    - 线程安全
    - 防止反射攻击
    - 自动处理序列化/反序列化
    - 代码简洁

2. **双重检查锁为什么要加volatile？**
    - 防止指令重排序导致返回未初始化的对象
    - 保证多线程环境下的可见性

3. **单例模式如何破坏？如何防护？**
    - 破坏方式：反射、序列化、克隆、多类加载器
    - 防护：枚举实现、readResolve方法、防止克隆

4. **单例模式与静态工具类的区别？**
    - 单例可以有状态，可以实现接口，可以继承
    - 静态类通常用于无状态的工具方法集合

单例模式是面试高频考点，理解各种实现方式的优缺点及适用场景非常重要。在实际开发中，应根据具体需求选择最合适的实现方式。