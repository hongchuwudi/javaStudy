### Java 动态代理设计模式全面总结

---

#### **一、代理模式基础**

##### **1. 核心思想**

- **代理模式**：通过一个代理对象控制对原始对象的访问，**在不修改原始对象代码**的前提下，**增强功能**（如日志、权限校验、性能监控等）。
- **核心角色**：
  | 角色 | 作用 |
  |-----------------|-------------------------------|
  | **真实对象**    | 实际执行业务逻辑的对象 |
  | **代理对象**    | 包装真实对象，增强其功能 |
  | **公共接口**    | 定义真实对象和代理对象的行为 |

##### **2. 静态代理 vs 动态代理**

| **特性**   | **静态代理**           | **动态代理**          |
|----------|--------------------|-------------------|
| **实现方式** | 手动编写代理类            | 运行时动态生成代理类        |
| **灵活性**  | 每个真实类需对应一个代理类，扩展性差 | 一个代理类可代理多个接口，灵活性高 |
| **适用场景** | 简单场景，代理类数量少        | 复杂场景，需代理多个类或接口    |

---

#### **二、Java 动态代理实现**

Java 动态代理基于 **接口** 实现，核心类为 `java.lang.reflect.Proxy` 和 `java.lang.reflect.InvocationHandler`。

##### **1. 核心 API**

| 类/接口                | 作用                                |
|---------------------|-----------------------------------|
| `Proxy`             | 创建动态代理类和实例                        |
| `InvocationHandler` | 定义代理对象的方法调用逻辑（通过实现 `invoke()` 方法） |
| `Method`            | 反射中的方法对象，表示被调用的方法                 |

##### **2. 动态代理步骤**

1. **定义公共接口**：
   ```java
   public interface UserService {
       void saveUser(String user);
   }
   ```

2. **实现真实对象**：
   ```java
   public class UserServiceImpl implements UserService {
       @Override
       public void saveUser(String user) {
           System.out.println("保存用户: " + user);
       }
   }
   ```

3. **实现 `InvocationHandler`**：
   ```java
   public class LogHandler implements InvocationHandler {
       private Object target; // 真实对象

       public LogHandler(Object target) {
           this.target = target;
       }

       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("方法调用前: " + method.getName());
           Object result = method.invoke(target, args); // 调用真实对象的方法
           System.out.println("方法调用后: " + method.getName());
           return result;
       }
   }
   ```

4. **生成代理对象**：
   ```java
   public class Client {
       public static void main(String[] args) {
           UserService realService = new UserServiceImpl();
           InvocationHandler handler = new LogHandler(realService);

           // 创建代理对象
           UserService proxy = (UserService) Proxy.newProxyInstance(
               realService.getClass().getClassLoader(),
               realService.getClass().getInterfaces(),
               handler
           );

           proxy.saveUser("张三"); // 通过代理对象调用方法
       }
   }
   ```

##### **3. 输出结果**

```
方法调用前: saveUser
保存用户: 张三
方法调用后: saveUser
```

---

#### **三、动态代理底层原理**

##### **1. 代理类生成过程**

1. **字节码生成**：`Proxy` 类在运行时动态生成代理类的字节码。
2. **类加载**：通过 `ClassLoader` 加载生成的字节码，创建代理类。
3. **反射调用**：代理类的方法调用会转发到 `InvocationHandler.invoke()`。

##### **2. 生成的代理类结构**

反编译动态生成的代理类（通过 `-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true` 导出）：

```java
public final class $Proxy0 extends Proxy implements UserService {
    private static Method m3; // 对应 saveUser 方法

    public $Proxy0(InvocationHandler h) {
        super(h);
    }

    static {
        m3 = Class.forName("UserService").getMethod("saveUser", String.class);
    }

    @Override
    public void saveUser(String user) {
        h.invoke(this, m3, new Object[]{user}); // 调用 InvocationHandler.invoke()
    }
}
```

---

#### **四、动态代理的局限性**

##### **1. 只能代理接口**

- **原因**：`Proxy.newProxyInstance()` 要求传入接口列表，生成的代理类默认继承 `Proxy`，而 Java 不支持多继承。
- **解决方案**：使用 **CGLIB**（基于类代理的第三方库）。

##### **2. 性能开销**

- **反射调用**：每次方法调用均通过反射，性能低于直接调用。
- **优化方案**：缓存 `Method` 对象，或使用 CGLIB 的 `MethodProxy`。

---

#### **五、CGLIB 动态代理**

##### **1. 核心特点**

- **基于继承**：通过生成目标类的子类实现代理。
- **无需接口**：可直接代理普通类（但不能代理 `final` 类或 `final` 方法）。

##### **2. 代码示例**

```java
public class CglibProxy implements MethodInterceptor {
    private Object target;

    public Object getProxy(Object target) {
        this.target = target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback(this);
        return enhancer.create();
    }

    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("CGLIB 方法调用前: " + method.getName());
        Object result = proxy.invokeSuper(obj, args); // 调用父类（真实对象）方法
        System.out.println("CGLIB 方法调用后: " + method.getName());
        return result;
    }
}

// 使用示例
public class Client {
    public static void main(String[] args) {
        UserServiceImpl realService = new UserServiceImpl();
        CglibProxy proxyFactory = new CglibProxy();
        UserServiceImpl proxy = (UserServiceImpl) proxyFactory.getProxy(realService);
        proxy.saveUser("李四");
    }
}
```

---

#### **六、动态代理应用场景**

| **场景**         | **说明**                               |
|----------------|--------------------------------------|
| **Spring AOP** | 通过 JDK/CGLIB 实现面向切面编程（如事务管理、日志、权限控制） |
| **RPC 框架**     | 远程方法调用（如 Dubbo、gRPC）中生成客户端代理         |
| **单元测试**       | Mock 对象（如 Mockito）                   |
| **延迟加载**       | 实现懒加载逻辑（如 Hibernate 的延迟初始化）          |

---

#### **七、动态代理最佳实践**

1. **优先使用 JDK 动态代理**：若目标对象实现了接口。
2. **CGLIB 补充**：代理未实现接口的类时使用。
3. **性能权衡**：反射调用有开销，高频场景需谨慎。
4. **避免循环调用**：在 `InvocationHandler` 中直接调用代理对象方法会导致死循环。

---

#### **八、总结**

| **维度**   | **JDK 动态代理** | **CGLIB 动态代理**    |
|----------|--------------|-------------------|
| **实现方式** | 基于接口         | 基于继承              |
| **依赖**   | 无需第三方库       | 需引入 CGLIB 库       |
| **性能**   | 反射调用略慢       | 通过 ASM 字节码操作更快    |
| **限制**   | 必须实现接口       | 无法代理 `final` 类或方法 |

**核心价值**：动态代理是 **解耦业务逻辑与横切关注点** 的利器，广泛应用于框架设计和复杂系统开发。