### Java 反射技术全面总结

---

#### **一、反射基础概念**

1. **什么是反射**  
   Java 反射（Reflection）允许程序在 **运行时** 动态获取类的信息、操作对象属性、调用方法，甚至可以突破访问权限限制（如访问私有成员）。
    - 核心类：`java.lang.Class`、`java.lang.reflect.*`（Method、Field、Constructor 等）。

2. **反射的核心作用**
    - 动态加载类（如插件化开发）。
    - 框架底层实现（如 Spring 的依赖注入、MyBatis 的 ORM）。
    - 动态代理（如 AOP 切面编程）。

---

#### **二、获取 Class 对象的 3 种方式**

1. **通过类名获取**
   ```java
   Class<?> clazz = String.class;
   ```

2. **通过对象获取**
   ```java
   String str = "hello";
   Class<?> clazz = str.getClass();
   ```

3. **通过全类名动态加载**
   ```java
   Class<?> clazz = Class.forName("java.lang.String");
   ```

---

#### **三、反射核心 API**

| 类/接口          | 用途                     | 示例                              |
|---------------|------------------------|---------------------------------|
| `Class`       | 描述类的元信息                | `clazz.getDeclaredMethods()`    |
| `Method`      | 描述方法信息                 | `method.invoke(obj, args)`      |
| `Field`       | 描述字段信息                 | `field.set(obj, value)`         |
| `Constructor` | 描述构造方法信息               | `constructor.newInstance(args)` |
| `Modifier`    | 解析修饰符（如 public、static） | `Modifier.isPublic(modifiers)`  |

---

#### **四、反射核心操作**

1. **创建对象**
    - 通过无参构造器：
      ```java
      Class<?> clazz = User.class;
      User user = (User) clazz.newInstance(); // 已过时，推荐用 getDeclaredConstructor().newInstance()
      ```
    - 通过有参构造器：
      ```java
      Constructor<?> constructor = clazz.getDeclaredConstructor(String.class, int.class);
      User user = (User) constructor.newInstance("张三", 25);
      ```

2. **调用方法**
   ```java
   Method method = clazz.getDeclaredMethod("setName", String.class);
   method.setAccessible(true); // 突破私有方法限制
   method.invoke(user, "李四");
   ```

3. **访问字段**
   ```java
   Field field = clazz.getDeclaredField("age");
   field.setAccessible(true); // 突破私有字段限制
   field.set(user, 30);
   ```

4. **操作数组**
   ```java
   int[] arr = (int[]) Array.newInstance(int.class, 5);
   Array.set(arr, 0, 100);
   ```

---

#### **五、反射高级特性**

1. **泛型擦除与反射**
    - 通过反射可以获取泛型的实际类型参数：
      ```java
      Type type = field.getGenericType(); // 获取字段的泛型类型
      if (type instanceof ParameterizedType) {
          ParameterizedType pType = (ParameterizedType) type;
          Type[] actualTypes = pType.getActualTypeArguments(); // 获取实际类型
      }
      ```

2. **动态代理**
   ```java
   public class MyProxy implements InvocationHandler {
       private Object target;
       public Object bind(Object target) {
           this.target = target;
           return Proxy.newProxyInstance(
               target.getClass().getClassLoader(),
               target.getClass().getInterfaces(),
               this
           );
       }
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           System.out.println("Before method");
           return method.invoke(target, args);
       }
   }
   ```

3. **注解处理**
   ```java
   Annotation[] annotations = clazz.getAnnotations();
   if (clazz.isAnnotationPresent(MyAnnotation.class)) {
       MyAnnotation anno = clazz.getAnnotation(MyAnnotation.class);
   }
   ```

---

#### **六、反射的优缺点**

| **优点**             | **缺点**                |
|--------------------|-----------------------|
| 灵活性强（动态加载类、方法调用）   | 性能较差（比直接调用慢 10~100 倍） |
| 实现框架底层机制（如 Spring） | 破坏封装性（可访问私有成员）        |
| 支持动态代理、插件化开发       | 代码可读性降低               |

---

#### **七、反射性能优化**

1. **缓存反射对象**
   ```java
   private static final Method setNameMethod;
   static {
       try {
           setNameMethod = User.class.getDeclaredMethod("setName", String.class);
           setNameMethod.setAccessible(true);
       } catch (NoSuchMethodException e) {
           throw new RuntimeException(e);
       }
   }
   ```

2. **使用 `MethodHandle`（Java 7+）**
   ```java
   MethodHandles.Lookup lookup = MethodHandles.lookup();
   MethodHandle handle = lookup.findVirtual(String.class, "length", MethodType.methodType(int.class));
   int length = (int) handle.invokeExact("hello");
   ```

---

#### **八、常见应用场景**

1. **框架开发**
    - Spring：依赖注入（`@Autowired`）、AOP 动态代理。
    - MyBatis：通过反射将 ResultSet 映射到 Java 对象。

2. **动态加载插件**
   ```java
   Class<?> pluginClass = Class.forName("com.example.PluginImpl");
   Plugin plugin = (Plugin) pluginClass.newInstance();
   plugin.execute();
   ```

3. **单元测试**
    - 通过反射调用私有方法进行测试：
      ```java
      Method method = clazz.getDeclaredMethod("privateMethod");
      method.setAccessible(true);
      method.invoke(obj);
      ```

---

#### **九、注意事项**

1. **安全性**
    - 反射可以绕过访问权限控制，需谨慎使用 `setAccessible(true)`。
    - 可通过 `SecurityManager` 限制反射权限。

2. **模块化系统（Java 9+）**
    - 在模块化项目中，默认禁止反射访问其他模块的非导出包，需在 `module-info.java` 中声明：
      ```java
      opens com.example.mypackage to spring.core;
      ```

---

#### **十、总结**

Java 反射是高级编程的核心技术，**灵活但需谨慎使用**。

- **适用场景**：框架开发、动态代理、插件化系统。
- **避免滥用**：在常规业务代码中优先使用直接调用，反射应作为“最后手段”。