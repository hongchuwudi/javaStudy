### Java 注解（Annotation）全面重点总结（由简到难）

---

#### **一、注解基础概念**

##### **1. 什么是注解？**

- **定义**：Java 注解是代码中的 **元数据标签**，用于为类、方法、字段等添加额外信息。
- **作用**：
    - 编译检查（如 `@Override`）。
    - 生成文档（如 `@Deprecated`）。
    - 框架配置（如 Spring 的 `@Autowired`）。
    - 运行时动态处理（如 JUnit 的 `@Test`）。

##### **2. 注解的本质**

- **本质**：注解本质是接口，继承自 `java.lang.annotation.Annotation`。
  ```java
  public interface MyAnnotation extends Annotation { ... }
  ```
- **注解的属性**：注解中的方法称为“属性”（如 `String value()`）。

---

#### **二、Java 内置注解**

##### **1. 常用内置注解**

| 注解                     | 作用                                          |
|------------------------|---------------------------------------------|
| `@Override`            | 标记方法覆盖父类方法，**编译时检查**                        |
| `@Deprecated`          | 标记方法/类已过时，**编译时警告**                         |
| `@SuppressWarnings`    | 抑制编译器警告（如 `@SuppressWarnings("unchecked")`） |
| `@SafeVarargs`         | 标记方法参数安全（泛型可变参数）                            |
| `@FunctionalInterface` | 标记接口是函数式接口（Java 8+）                         |

##### **2. 示例**

```java
@Override
public String toString() { ... }

@Deprecated
public void oldMethod() { ... }
```

---

#### **三、元注解（Meta-Annotation）**

**元注解**：用于定义其他注解的注解。

##### **1. 核心元注解**

| 元注解           | 作用                    |
|---------------|-----------------------|
| `@Target`     | 指定注解可应用的目标（类、方法、字段等）  |
| `@Retention`  | 指定注解的保留策略（源码、编译时、运行时） |
| `@Documented` | 标记注解是否包含在 Javadoc 中   |
| `@Inherited`  | 标记注解是否可被子类继承          |
| `@Repeatable` | 标记注解可重复使用（Java 8+）    |

##### **2. `@Target` 参数**

```java
@Target(ElementType.TYPE)             // 类/接口/枚举
@Target(ElementType.METHOD)           // 方法
@Target(ElementType.FIELD)            // 字段
@Target(ElementType.PARAMETER)        // 方法参数
@Target(ElementType.CONSTRUCTOR)      // 构造方法
@Target(ElementType.ANNOTATION_TYPE)  // 其他注解
```

##### **3. `@Retention` 参数**

```java
@Retention(RetentionPolicy.SOURCE)    // 仅源码保留（编译后丢弃）
@Retention(RetentionPolicy.CLASS)     // 编译时保留（默认，JVM 不加载）
@Retention(RetentionPolicy.RUNTIME)   // 运行时保留（可通过反射读取）
```

---

#### **四、自定义注解**

##### **1. 定义注解**

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "default";  // 属性（类似方法）
    int priority() default 0;
}
```

##### **2. 使用注解**

```java
public class MyClass {
    @MyAnnotation(value = "test", priority = 1)
    public void myMethod() { ... }
}
```

##### **3. 注解属性规则**

- 属性类型：基本类型、`String`、`Class`、枚举、注解、上述类型的数组。
- 默认值：用 `default` 指定（如 `String value() default ""`）。
- 数组赋值：`names = {"A", "B"}` 或 `names = "A"`（单元素简写）。

---

#### **五、注解处理**

##### **1. 反射读取注解（运行时处理）**

```java
Method method = MyClass.class.getMethod("myMethod");
if (method.isAnnotationPresent(MyAnnotation.class)) {
    MyAnnotation anno = method.getAnnotation(MyAnnotation.class);
    String value = anno.value();  // "test"
    int priority = anno.priority(); // 1
}
```

##### **2. 编译时处理（APT）**

- **原理**：通过 `javax.annotation.processing.Processor` 接口处理注解，生成代码。
- **工具**：使用 Lombok 的 `@Data` 或 MapStruct 的 `@Mapper`。

##### **3. 框架集成**

- **Spring**：`@Component`, `@Autowired`, `@RequestMapping`。
- **JUnit**：`@Test`, `@BeforeEach`。
- **Hibernate**：`@Entity`, `@Table`。

---

#### **六、高级特性**

##### **1. 重复注解（Java 8+）**

- **定义**：
  ```java
  @Repeatable(MyAnnotations.class)
  public @interface MyAnnotation { ... }

  public @interface MyAnnotations {
      MyAnnotation[] value();
  }
  ```
- **使用**：
  ```java
  @MyAnnotation("A")
  @MyAnnotation("B")
  public void myMethod() { ... }
  ```

##### **2. 类型注解（Java 8+）**

- **用途**：增强类型检查（如 `@NonNull`）。
- **示例**：
  ```java
  public void process(@NonNull String text) { ... }
  ```

##### **3. 注解与动态代理**

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable { ... }

// 动态代理增强
public class LoggingHandler implements InvocationHandler {
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) {
        if (method.isAnnotationPresent(Loggable.class)) {
            System.out.println("Logging method: " + method.getName());
        }
        return method.invoke(target, args);
    }
}
```

---

#### **七、实战应用**

##### **1. 自定义 ORM 框架**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface Entity {
    String tableName();
}

@Entity(tableName = "users")
public class User { ... }
```

##### **2. 实现 AOP 日志**

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime { ... }

public class LogAspect {
    @Around("@annotation(LogExecutionTime)")
    public Object logTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long duration = System.currentTimeMillis() - start;
        System.out.println("Method executed in " + duration + "ms");
        return result;
    }
}
```

---

#### **八、注意事项**

1. **性能影响**：反射读取注解有一定性能开销，避免高频使用。
2. **设计原则**：注解应保持简洁，避免过度复杂。
3. **兼容性**：编译时注解需考虑跨版本兼容性。
4. **安全**：运行时注解可能被恶意修改，需结合安全机制。

---

### **总结**

| **级别** | **核心内容**                                 |
|--------|------------------------------------------|
| **初级** | 内置注解、元注解、自定义注解                           |
| **中级** | 反射处理注解、编译时注解处理（APT）                      |
| **高级** | 重复注解、类型注解、动态代理结合注解、框架级应用（如 Spring、JUnit） |

**学习路径**：

1. 先掌握基本注解和自定义注解。
2. 熟悉反射读取注解的机制。
3. 深入编译时处理和框架集成。
4. 实战中结合设计模式（如工厂、代理）提升代码灵活性。