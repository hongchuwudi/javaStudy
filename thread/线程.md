## **一、线程基础**

### **1. 线程创建方式**

- **继承 `Thread` 类**：
  ```java
  class MyThread extends Thread {
      public void run() { /* 任务逻辑 */ }
  }
  new MyThread().start();
  ```
- **实现 `Runnable` 接口**（推荐，避免单继承限制）：
  ```java
  Runnable task = () -> { /* 任务逻辑 */ };
  new Thread(task).start();
  ```
- **实现 `Callable` + `Future`**（支持返回值）：
  ```java
  ExecutorService executor = Executors.newSingleThreadExecutor();
  Future<Integer> future = executor.submit(() -> { return 42; });
  Integer result = future.get(); // 阻塞获取结果
  ```

### **2. 线程生命周期**

- **6种状态**（Java 5+）：
  ```java
  public enum State { NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED }
  ```
- **状态转换**：
    - `NEW` → `RUNNABLE`：调用 `start()`。
    - `RUNNABLE` → `BLOCKED`：等待锁（synchronized）。
    - `RUNNABLE` → `WAITING`：调用 `wait()`、`join()`。
    - `RUNNABLE` → `TIMED_WAITING`：调用 `sleep(ms)`、`wait(timeout)`。

---

## **二、线程同步与锁**

### **1. `synchronized` 关键字**

- **同步代码块**：
  ```java
  synchronized (lockObject) { /* 临界区代码 */ }
  ```
- **同步方法**：
  ```java
  public synchronized void method() { /* 临界区 */ }
  ```
- **锁的粒度**：类锁（`static synchronized`）与对象锁。

### **2. `Lock` 接口**

- **显式锁**（`ReentrantLock`）：
  ```java
  Lock lock = new ReentrantLock();
  lock.lock();
  try { /* 临界区 */ } finally { lock.unlock(); }
  ```
- **高级特性**：
    - 可中断锁：`lockInterruptibly()`。
    - 公平锁：`new ReentrantLock(true)`。
    - 超时锁：`tryLock(timeout, unit)`。

### **3. `volatile` 关键字**

- **作用**：
    - 保证可见性：修改立即刷新到主内存。
    - 禁止指令重排序（通过内存屏障）。
- **适用场景**：单次读写操作的共享变量。

### **4. 原子类（`java.util.concurrent.atomic`）**

- **无锁操作**（基于 CAS）：
  ```java
  AtomicInteger count = new AtomicInteger(0);
  count.incrementAndGet();
  ```
- **常见类**：`AtomicInteger`, `AtomicReference`, `LongAdder`（高并发累加更高效）。

---

## **三、线程通信**

### **1. `wait()` / `notify()`**

- **使用条件**：必须在 `synchronized` 块内调用。
  ```java
  synchronized (lock) {
      lock.wait(); // 释放锁并等待
      lock.notify(); // 唤醒一个等待线程
  }
  ```

### **2. `Condition` 接口**

- **与 `Lock` 配合使用**：
  ```java
  Lock lock = new ReentrantLock();
  Condition condition = lock.newCondition();
  lock.lock();
  try {
      condition.await(); // 类似 wait()
      condition.signal(); // 类似 notify()
  } finally { lock.unlock(); }
  ```

---

## **四、线程池（`Executor` 框架）**

### **1. 核心参数（`ThreadPoolExecutor`）**

- **参数定义**：
  ```java
  new ThreadPoolExecutor(
      corePoolSize, // 核心线程数
      maximumPoolSize, // 最大线程数
      keepAliveTime, // 空闲线程存活时间
      TimeUnit unit, // 时间单位
      BlockingQueue<Runnable> workQueue, // 任务队列
      RejectedExecutionHandler handler // 拒绝策略
  );
  ```

### **2. 常见线程池类型**

| **类型**                 | **特点**               |
|------------------------|----------------------|
| `FixedThreadPool`      | 固定线程数，队列无界（可能导致 OOM） |
| `CachedThreadPool`     | 线程数无上限（可能导致线程过多）     |
| `SingleThreadExecutor` | 单线程，保证任务顺序执行         |
| `ScheduledThreadPool`  | 支持定时/周期性任务           |

### **3. 拒绝策略**

- **默认策略**：`AbortPolicy`（抛出异常）。
- **其他策略**：`CallerRunsPolicy`（调用者线程执行）、`DiscardOldestPolicy`（丢弃最旧任务）。

---

## **五、并发工具类**

### **1. `CountDownLatch`**

- **用途**：等待多个线程完成。
  ```java
  CountDownLatch latch = new CountDownLatch(3);
  latch.countDown(); // 计数器减1
  latch.await(); // 阻塞直到计数器归零
  ```

### **2. `CyclicBarrier`**

- **用途**：多个线程相互等待至屏障点。
  ```java
  CyclicBarrier barrier = new CyclicBarrier(3, () -> { /* 所有线程到达后执行 */ });
  barrier.await(); // 线程在此等待
  ```

### **3. `Semaphore`**

- **用途**：控制并发访问资源的线程数。
  ```java
  Semaphore semaphore = new Semaphore(5); // 允许5个线程同时访问
  semaphore.acquire(); // 获取许可
  semaphore.release(); // 释放许可
  ```

### **4. `Exchanger`**

- **用途**：两个线程间交换数据。
  ```java
  Exchanger<String> exchanger = new Exchanger<>();
  String data = exchanger.exchange("data"); // 阻塞等待交换
  ```

---

## **六、高级特性**

### **1. `Fork/Join` 框架**

- **分治任务**（适合递归分解的任务）：
  ```java
  class Task extends RecursiveTask<Integer> {
      protected Integer compute() {
          // 拆分任务并合并结果
      }
  }
  ForkJoinPool pool = new ForkJoinPool();
  pool.invoke(new Task());
  ```

### **2. `CompletableFuture`（Java 8+）**

- **异步编程**：
  ```java
  CompletableFuture.supplyAsync(() -> "result")
      .thenApplyAsync(s -> s.toUpperCase())
      .thenAccept(System.out::println);
  ```

### **3. 虚拟线程（Java 19+ 预览）**

- **轻量级线程**（协程）：
  ```java
  Thread.startVirtualThread(() -> { /* 任务 */ });
  ```

---

## **七、最佳实践与常见问题**

### **1. 避免死锁**

- **条件**：互斥、请求保持、不可剥夺、循环等待。
- **解决方案**：按顺序获取锁、设置超时时间。

### **2. 线程安全设计**

- **不可变对象**：`String`、`BigDecimal`。
- **并发容器**：`ConcurrentHashMap`、`CopyOnWriteArrayList`。

### **3. 资源关闭**

- **使用 `try-with-resources`**（支持 `AutoCloseable` 接口）。

### **4. 异常处理**

- **捕获线程异常**：
  ```java
  Thread.setDefaultUncaughtExceptionHandler((t, e) -> { /* 处理逻辑 */ });
  ```

---

## **八、性能优化**

- **减少锁竞争**：缩小同步范围、使用分段锁。
- **避免阻塞**：异步非阻塞（如 NIO、CompletableFuture）。
- **监控工具**：JConsole、VisualVM、Arthas。

---

掌握这些知识后，可进一步研究 JMM（Java 内存模型）、`ThreadLocal` 内存泄漏问题，以及高并发场景下的性能调优。