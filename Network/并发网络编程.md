### Java 并发网络编程重点总结

---

#### **一、并发网络编程的核心问题**

1. **高并发场景**：同时处理大量客户端连接（如 Web 服务器、即时通讯系统）。
2. **资源竞争**：多线程共享资源（如数据库连接、Socket）时的线程安全问题。
3. **性能瓶颈**：传统阻塞 I/O（BIO）模型线程数过多导致系统资源耗尽。

---

#### **二、传统 BIO 模型的并发处理**

##### **1. 多线程模式**

- **原理**：为每个客户端连接创建一个独立线程。
- **代码示例**：
  ```java
  ServerSocket serverSocket = new ServerSocket(8080);
  while (true) {
      Socket socket = serverSocket.accept();
      new Thread(() -> {
          // 处理客户端请求
      }).start();
  }
  ```
- **缺点**：
    - 线程数随连接数线性增长（如 10,000 连接 → 10,000 线程）。
    - 线程创建/销毁开销大，内存占用高（每个线程默认约 1MB 栈内存）。

##### **2. 线程池优化**

- **原理**：使用固定大小线程池（如 `Executors.newFixedThreadPool(100)`）限制最大线程数。
- **代码示例**：
  ```java
  ExecutorService threadPool = Executors.newFixedThreadPool(100);
  ServerSocket serverSocket = new ServerSocket(8080);
  while (true) {
      Socket socket = serverSocket.accept();
      threadPool.execute(() -> {
          // 处理客户端请求
      });
  }
  ```
- **缺点**：
    - 阻塞 I/O 模型下，线程池线程可能被长时间阻塞（如等待数据库响应）。
    - 无法充分利用 CPU，吞吐量受限于线程池大小。

---

#### **三、NIO 非阻塞模型（Java New I/O）**

##### **1. 核心组件**

| 类/接口       | 作用                                         |
|------------|--------------------------------------------|
| `Selector` | 监听多个通道的事件（连接、读、写），单线程管理多连接                 |
| `Channel`  | 双向通信通道（替代 `Socket`/`ServerSocket`），支持非阻塞模式 |
| `Buffer`   | 数据缓冲区，实现高效读写                               |

##### **2. NIO 编程步骤**

1. **创建 `Selector`**：
   ```java
   Selector selector = Selector.open();
   ```
2. **创建 `ServerSocketChannel` 并绑定端口**：
   ```java
   ServerSocketChannel serverChannel = ServerSocketChannel.open();
   serverChannel.bind(new InetSocketAddress(8080));
   serverChannel.configureBlocking(false); // 非阻塞模式
   serverChannel.register(selector, SelectionKey.OP_ACCEPT); // 注册 accept 事件
   ```
3. **事件循环处理**：
   ```java
   while (true) {
       selector.select(); // 阻塞等待就绪的事件
       Set<SelectionKey> keys = selector.selectedKeys();
       Iterator<SelectionKey> iter = keys.iterator();
       while (iter.hasNext()) {
           SelectionKey key = iter.next();
           iter.remove();
           if (key.isAcceptable()) {
               // 处理新连接
               SocketChannel clientChannel = serverChannel.accept();
               clientChannel.configureBlocking(false);
               clientChannel.register(selector, SelectionKey.OP_READ);
           } else if (key.isReadable()) {
               // 读取数据
               SocketChannel clientChannel = (SocketChannel) key.channel();
               ByteBuffer buffer = ByteBuffer.allocate(1024);
               clientChannel.read(buffer);
               // 处理数据...
           }
       }
   }
   ```

##### **3. 优点**

- **单线程处理多连接**：通过 `Selector` 实现高并发（如 1 个线程管理 10,000 连接）。
- **非阻塞 I/O**：避免线程因等待 I/O 而阻塞，提升 CPU 利用率。

##### **4. 缺点**

- 编程复杂度高（需处理事件驱动、缓冲区管理）。
- 需自行处理粘包/拆包问题。

---

#### **四、Netty 框架（基于 NIO 的高性能网络库）**

##### **1. 核心优势**

- 简化 NIO 开发，提供 **事件驱动、异步非阻塞** 的 API。
- 内置 **高性能线程模型**（主从 Reactor 多线程模型）。
- 支持 **零拷贝**、**内存池** 等优化技术。

##### **2. 核心组件**

| 组件                | 作用                                   |
|-------------------|--------------------------------------|
| `EventLoopGroup`  | 线程池，处理 I/O 事件（如 `NioEventLoopGroup`） |
| `ServerBootstrap` | 服务端启动类，配置线程模型、Channel 类型等            |
| `ChannelHandler`  | 业务逻辑处理器（如编解码、数据读写）                   |

##### **3. 代码示例（Netty 服务端）**

```java
public class NettyServer {
    public static void main(String[] args) {
        EventLoopGroup bossGroup = new NioEventLoopGroup(1); // 处理连接请求
        EventLoopGroup workerGroup = new NioEventLoopGroup(); // 处理 I/O 事件

        try {
            ServerBootstrap bootstrap = new ServerBootstrap();
            bootstrap.group(bossGroup, workerGroup)
                     .channel(NioServerSocketChannel.class)
                     .childHandler(new ChannelInitializer<SocketChannel>() {
                         @Override
                         protected void initChannel(SocketChannel ch) {
                             ch.pipeline().addLast(new ServerHandler());
                         }
                     });

            ChannelFuture future = bootstrap.bind(8080).sync();
            future.channel().closeFuture().sync();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}

// 自定义处理器
public class ServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ByteBuf buf = (ByteBuf) msg;
        System.out.println("收到数据: " + buf.toString(CharsetUtil.UTF_8));
        ctx.writeAndFlush(Unpooled.copiedBuffer("Hello Client", CharsetUtil.UTF_8));
    }
}
```

---

#### **五、并发网络编程优化技巧**

1. **线程模型选择**：
    - **BIO + 线程池**：适合连接数较少（< 1000）的简单场景。
    - **NIO/Netty**：适合高并发（> 10,000 连接）的复杂场景。

2. **避免阻塞操作**：
    - 将阻塞操作（如数据库查询）交给单独线程池处理，避免占用 I/O 线程。

3. **粘包/拆包处理**：
    - **固定长度**：每条消息定长（如 `ByteBuf.readBytes(100)`）。
    - **分隔符**：使用特殊字符（如 `\n`）分隔消息。
    - **长度字段**：消息头中定义长度字段（如 `LengthFieldBasedFrameDecoder`）。

4. **资源管理**：
    - 使用对象池（如 Netty 的 `ByteBuf` 内存池）减少 GC 压力。
    - 及时关闭 `Channel` 和释放 `ByteBuf`。

---

#### **六、总结**

| **模型**        | **适用场景**      | **优点**           | **缺点**       |
|---------------|---------------|------------------|--------------|
| **BIO + 多线程** | 低并发、简单业务      | 编程简单             | 线程资源消耗大      |
| **NIO**       | 高并发、复杂 I/O 操作 | 单线程管理多连接，性能高     | 编程复杂，需处理底层细节 |
| **Netty**     | 高并发、生产级网络应用   | 简化 NIO，内置优化，扩展性强 | 学习曲线较陡       |

**学习建议**：

- 掌握 NIO 核心原理（Selector、Channel、Buffer）。
- 熟练使用 Netty 框架开发高性能服务端。
- 实战中关注线程安全、资源管理和性能调优。