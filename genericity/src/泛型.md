# Java 泛型知识全面总结

## 一、泛型基础概念

### 1. 泛型的本质

- **参数化类型**：将类型作为参数传递
- **编译时特性**：泛型信息在编译后会擦除（类型擦除）
- **主要目的**：
    - 类型安全
    - 消除强制类型转换
    - 提高代码复用性

### 2. 基本语法

```java
// 类泛型
class Box<T> {
    private T content;
    // getter/setter...
}

// 接口泛型
interface List<E> {
    void add(E element);
    E get(int index);
}

// 方法泛型
public <T> T doSomething(T param) {
    return param;
}
```

## 二、泛型类型参数

### 1. 类型参数命名规范

- E - Element (集合元素)
- K - Key (键)
- V - Value (值)
- N - Number (数字)
- T - Type (通用类型)
- S,U,V - 第二、第三、第四类型

### 2. 多类型参数

```java
class Pair<K, V> {
    private K key;
    private V value;
    // ...
}
```

## 三、泛型使用场景

### 1. 泛型类

```java
public class Container<T> {
    private T value;
    
    public Container(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
}
```

### 2. 泛型接口

```java
public interface Generator<T> {
    T next();
}
```

### 3. 泛型方法

```java
public <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.print(element + " ");
    }
}
```

## 四、泛型约束与边界

### 1. 上边界通配符(extends)

```java
// 接受Number及其子类
public double sum(List<? extends Number> list) {
    double sum = 0;
    for (Number num : list) {
        sum += num.doubleValue();
    }
    return sum;
}
```

### 2. 下边界通配符(super)

```java
// 接受Integer及其父类
public void addNumbers(List<? super Integer> list) {
    for (int i = 1; i <= 10; i++) {
        list.add(i);
    }
}
```

### 3. 多重边界

```java
<T extends Number & Comparable<T>> void sort(List<T> list) {
    // T必须同时是Number子类和实现Comparable接口
}
```

## 五、类型擦除与桥方法

### 1. 类型擦除规则

- 无边界类型参数 → Object
- 有extends边界 → 边界类型
- 保留泛型信息在Signature属性中

### 2. 桥方法示例

```java
// 编译器生成的桥方法
public class Node<T> {
    public void setData(T data) { ... }
}

// 擦除后
public class Node {
    public void setData(Object data) { ... }
}
```

## 六、泛型与数组

### 1. 泛型数组限制

```java
// 不允许创建泛型数组
// T[] array = new T[10]; // 编译错误

// 正确方式
T[] array = (T[]) new Object[10]; // 警告
```

### 2. 可变参数与泛型

```java
@SafeVarargs
public final <T> void printItems(T... items) {
    for (T item : items) {
        System.out.println(item);
    }
}
```

## 七、泛型继承关系

### 1. 泛型类继承

```java
class StringBox extends Box<String> { ... }
```

### 2. 通配符继承关系

- `List<?>` 是 `List<? extends Object>` 的简写
- `List<String>` 是 `List<? extends String>` 的子类型
- `List<Object>` 不是 `List<String>` 的父类型

## 八、泛型最佳实践

### 1. PECS原则

- **Producer Extends** (生产者用extends)
- **Consumer Super** (消费者用super)

```java
// 从src读取，写入dest
public static <T> void copy(List<? extends T> src, List<? super T> dest) {
    for (T item : src) {
        dest.add(item);
    }
}
```

### 2. 避免原始类型

```java
List list = new ArrayList(); // 原始类型 - 避免
List<String> list = new ArrayList<>(); // 正确
```

### 3. 类型安全的异构容器

```java
class Favorites {
    private Map<Class<?>, Object> map = new HashMap<>();
    
    public <T> void putFavorite(Class<T> type, T instance) {
        map.put(type, type.cast(instance));
    }
    
    public <T> T getFavorite(Class<T> type) {
        return type.cast(map.get(type));
    }
}
```

## 九、Java 8+ 泛型增强

### 1. 目标类型推断

```java
List<String> list = new ArrayList<>(); // 钻石操作符
Collections.emptyList(); // 推断返回类型
```

### 2. 泛型与Lambda

```java
Function<String, Integer> parser = Integer::parseInt;
```

### 3. 泛型异常处理

```java
<T extends Throwable> T sneakyThrow(Throwable e) throws T {
    throw (T) e;
}
```

## 十、常见问题与限制

### 1. 泛型限制

- 不能实例化类型参数：`new T()`
- 不能创建泛型数组：`new T[10]`
- 不能用于静态变量
- 不能用于异常类（catch块）

### 2. 类型擦除导致的问题

```java
// 编译错误 - 方法签名冲突
void method(List<String> list) {}
void method(List<Integer> list) {}
```

### 3. 与反射的交互

```java
// 获取泛型类型信息
Type type = ((ParameterizedType)getClass()
    .getGenericSuperclass()).getActualTypeArguments()[0];
```

## 十一、高级泛型技巧

### 1. 自限定类型

```java
class SelfBounded<T extends SelfBounded<T>> {
    // ...
}
```

### 2. 模拟元组

```java
public class Tuple2<A, B> {
public class Tuple2<A, B> {
    public final A a;
    public final B b;
    // ...
}
```

### 3. 构建器模式

```java
class Builder<T extends Builder<T>> {
    T self() { return (T) this; }
}
```

泛型是Java类型系统的强大扩展，正确使用泛型可以：

- 提高代码类型安全性
- 减少强制类型转换
- 增强API灵活性
- 提高代码复用性

深入理解泛型对于编写高质量、可维护的Java代码至关重要。