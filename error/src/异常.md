# Java 异常处理知识大全：try-catch-throw 全面总结

## 一、异常处理体系

### 1. Java异常分类

```
Throwable
├── Error (不可处理，如OutOfMemoryError)
└── Exception
    ├── RuntimeException (未检查异常)
    │   ├── NullPointerException
    │   ├── IndexOutOfBoundsException
    │   └── ...
    └── 非RuntimeException (已检查异常)
        ├── IOException
        ├── SQLException
        └── ...
```

### 2. 检查型异常 vs 非检查型异常

| 特性   | 检查型异常(Checked)                  | 非检查型异常(Unchecked)                              |
|------|---------------------------------|------------------------------------------------|
| 继承关系 | 继承Exception但不继承RuntimeException | 继承RuntimeException或Error                       |
| 处理要求 | 必须捕获或声明抛出                       | 可不处理                                           |
| 典型例子 | IOException, SQLException       | NullPointerException, IllegalArgumentException |

## 二、try-catch-finally 基础语法

### 1. 基本结构

```java
try {
    // 可能抛出异常的代码
} catch (ExceptionType1 e1) {
    // 处理ExceptionType1类型的异常
} catch (ExceptionType2 e2) {
    // 处理ExceptionType2类型的异常
} finally {
    // 无论是否发生异常都会执行的代码
}
```

### 2. 多重catch块注意事项

- **顺序原则**：子类异常在前，父类异常在后
- **Java 7+** 多重捕获语法：
  ```java
  catch (IOException | SQLException e) {
      // 处理IO或SQL异常
  }
  ```

### 3. finally块特点

- **始终执行**：即使try或catch中有return语句
- **资源释放**：传统资源释放方式
  ```java
  FileInputStream fis = null;
  try {
      fis = new FileInputStream("file.txt");
      // ...
  } finally {
      if (fis != null) {
          fis.close(); // 确保资源释放
      }
  }
  ```

## 三、throw 和 throws

### 1. throw 语句

```java
if (age < 0) {
    throw new IllegalArgumentException("年龄不能为负数");
}
```

### 2. throws 声明

```java
public void readFile() throws IOException {
    // 可能抛出IOException的方法
}
```

### 3. 方法重写规则

- 子类方法抛出的异常不能比父类方法更宽泛
- 可以抛出更具体的异常或不抛出异常

## 四、try-with-resources (Java 7+)

### 1. 语法结构

```java
try (ResourceType res1 = new ResourceType();
     ResourceType res2 = new ResourceType()) {
    // 使用资源的代码
} // 自动调用close()
```

### 2. 要求条件

- 资源必须实现`AutoCloseable`接口
- 多个资源按声明顺序逆序关闭

### 3. 优势

- 代码更简洁
- 自动处理资源关闭
- 抑制异常不会丢失原始异常

## 五、异常处理最佳实践

### 1. 异常选择原则

- **业务异常**：自定义继承`RuntimeException`
- **系统异常**：使用标准异常如`IllegalArgumentException`
- **恢复性异常**：使用检查型异常

### 2. 异常处理建议

- **不要忽略异常**：空的catch块是坏味道
- **具体异常优先**：避免直接捕获`Exception`
- **异常信息丰富**：包含诊断信息
  ```java
  catch (FileNotFoundException e) {
      throw new MyException("文件未找到: " + fileName, e);
  }
  ```

### 3. 性能考虑

- **避免在循环中使用try-catch**
- **异常实例创建开销大**：JVM需要填充堆栈轨迹

## 六、自定义异常

### 1. 创建自定义异常

```java
public class BusinessException extends RuntimeException {
    private String errorCode;
    
    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
    
    // getter方法...
}
```

### 2. 使用场景

- 业务规则违反
- 特定领域错误
- 统一异常处理

## 七、异常链(Chained Exceptions)

### 1. 异常包装

```java
try {
    // ...
} catch (IOException e) {
    throw new MyException("操作失败", e); // 保留原始异常
}
```

### 2. 获取原因异常

```java
try {
    // ...
} catch (MyException e) {
    Throwable cause = e.getCause(); // 获取原始IOException
}
```

## 八、Java 9+ 增强特性

### 1. try-with-resources 增强

```java
// Java 9前需要声明资源变量
try (InputStream is = getInputStream()) {...}

// Java 9+ 可使用已存在的final/等效final变量
InputStream is = getInputStream();
try (is) {...}
```

### 2. 堆栈轨迹过滤

```java
StackTraceElement[] stackTrace = e.getStackTrace();
// Java 9+ 可以过滤堆栈帧
e.setStackTrace(Arrays.stream(stackTrace)
                   .filter(f -> f.getClassName().startsWith("com.myapp"))
                   .toArray(StackTraceElement[]::new));
```

## 九、常见异常处理模式

### 1. 防御式编程

```java
public void process(String input) {
    if (input == null) {
        throw new IllegalArgumentException("输入不能为null");
    }
    // 业务逻辑...
}
```

### 2. 模板方法模式

```java
public <T> T executeWithRetry(Callable<T> task, int maxRetries) {
    for (int i = 0; i < maxRetries; i++) {
        try {
            return task.call();
        } catch (Exception e) {
            if (i == maxRetries - 1) throw e;
            // 日志记录...
        }
    }
    throw new IllegalStateException("不应执行到此处");
}
```

### 3. 全局异常处理(Spring示例)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException e) {
        return ResponseEntity.badRequest()
               .body(new ErrorResponse(e.getErrorCode(), e.getMessage()));
    }
}
```

## 十、异常处理常见错误

1. **过度使用检查型异常**：导致代码冗余
2. **捕获异常过于宽泛**：`catch(Exception e)`掩盖问题
3. **异常信息不明确**：如`throw new Exception("错误发生")`
4. **忽略原始异常**：未正确传递异常链
5. **finally块中return**：会覆盖try/catch中的返回值

掌握Java异常处理是编写健壮程序的关键。合理的异常处理策略应该：

- 区分业务异常和系统异常
- 保持异常信息完整和有价值
- 遵循"早抛出，晚捕获"原则
- 在适当层级处理异常（如UI层、服务层、DAO层各有不同处理策略）