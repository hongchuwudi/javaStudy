# Java多态知识全面总结

多态(Polymorphism)是面向对象编程的三大特性之一(封装、继承、多态)，它允许不同类的对象对同一消息做出不同的响应。

## 一、多态的基本概念

1. **定义**：
    - 多态是指同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果
    - "一个接口，多种实现"

2. **核心思想**：
    - 父类引用指向子类对象
    - 运行时确定实际调用的方法

3. **Java中多态的表现形式**：
    - 方法重写(Override)
    - 接口实现
    - 方法重载(Overload) - 编译时多态

## 二、多态的实现条件

1. **必要条件**：
    - 继承关系(类继承或接口实现)
    - 方法重写(子类重写父类方法)
    - 向上转型(父类引用指向子类对象)

2. **典型实现代码结构**：

```java
class Animal {
    public void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Cat meows");
    }
}

public class TestForEach2 {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 向上转型
        myAnimal.sound(); // 输出"Dog barks" (多态)
        
        myAnimal = new Cat();
        myAnimal.sound(); // 输出"Cat meows"
    }
}
```

## 三、多态的类型

1. **编译时多态(静态多态)**：
    - 通过方法重载实现
    - 在编译时确定调用的方法
    - 示例：

```java
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}
```

2. **运行时多态(动态多态)**：
    - 通过方法重写实现
    - 在运行时确定调用的方法
    - 示例(见上文的Animal/Dog/Cat示例)

## 四、多态的实现机制

1. **JVM方法调用机制**：
    - 静态绑定：编译时确定(私有方法、静态方法、final方法、构造器)
    - 动态绑定：运行时基于对象类型确定(实例方法)

2. **虚方法表(Virtual Method Table)**：
    - JVM为每个类维护一个虚方法表
    - 包含该类所有可被重写的方法入口地址
    - 子类重写方法时会替换表中的对应项

## 五、多态的应用场景

1. **接口编程**：

```java
interface Shape {
    double area();
}

class Circle implements Shape {
    public double area() { /* 实现 */ }
}

class Square implements Shape {
    public double area() { /* 实现 */ }
}

// 使用多态处理不同形状
public double totalArea(List<Shape> shapes) {
    double total = 0;
    for (Shape s : shapes) {
        total += s.area(); // 多态调用
    }
    return total;
}
```

2. **工厂模式**：

```java
abstract class Product {
    abstract void use();
}

class ProductA extends Product {
    void use() { System.out.println("Using A"); }
}

class ProductB extends Product {
    void use() { System.out.println("Using B"); }
}

class Factory {
    public static Product create(String type) {
        switch(type) {
            case "A": return new ProductA();
            case "B": return new ProductB();
            default: throw new IllegalArgumentException();
        }
    }
}
```

3. **策略模式**：

```java
interface SortingStrategy {
    void sort(int[] data);
}

class QuickSort implements SortingStrategy {
    public void sort(int[] data) { /* 实现 */ }
}

class MergeSort implements SortingStrategy {
    public void sort(int[] data) { /* 实现 */ }
}

class Sorter {
    private SortingStrategy strategy;
    
    public Sorter(SortingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sortData(int[] data) {
        strategy.sort(data); // 多态调用
    }
}
```

## 六、多态的高级特性

1. **instanceof运算符**：
    - 检查对象是否是特定类的实例
    - 用于向下转型前的安全检查

```java
if (animal instanceof Dog) {
    Dog myDog = (Dog) animal;
    myDog.bark();
}
```

2. **getClass()方法**：
    - 获取对象的实际运行时类

```java
System.out.println(animal.getClass().getName());
```

3. **协变返回类型(Java 5+)**：
    - 子类重写方法时，可以返回更具体的类型

```java
class Parent {
    Parent get() { return this; }
}

class Child extends Parent {
    @Override
    Child get() { return this; } // 协变返回
}
```

## 七、多态使用的注意事项

1. **字段没有多态性**：
    - 字段访问由引用类型决定，不是运行时对象类型

```java
class Parent { String name = "Parent"; }
class Child extends Parent { String name = "Child"; }

Parent p = new Child();
System.out.println(p.name); // 输出"Parent"
```

2. **静态方法没有多态性**：
    - 静态方法调用由编译时类型决定

```java
class Parent {
    static void method() { System.out.println("Parent"); }
}

class Child extends Parent {
    static void method() { System.out.println("Child"); }
}

Parent p = new Child();
p.method(); // 输出"Parent"
```

3. **私有方法不能被重写**：
    - 私有方法对子类不可见，不存在多态

4. **构造器中的多态问题**：
    - 避免在构造器中调用可被重写的方法
    - 此时子类可能还未完全初始化

## 八、多态的优点

1. **可扩展性**：添加新子类不影响现有代码
2. **可替换性**：子类对象可以替换父类对象
3. **接口灵活性**：通过接口编程降低耦合度
4. **简化代码**：统一处理不同子类对象

## 九、多态与设计原则

1. **开闭原则(OCP)**：
    - 对扩展开放，对修改关闭
    - 通过多态实现新功能扩展而不修改现有代码

2. **里氏替换原则(LSP)**：
    - 子类必须能够替换它们的基类
    - 多态的基础保证

3. **依赖倒置原则(DIP)**：
    - 高层模块不应依赖低层模块，都应依赖抽象
    - 多态是实现这一原则的关键技术

掌握多态是Java面向对象编程的核心能力，它能够显著提高代码的灵活性、可扩展性和可维护性。