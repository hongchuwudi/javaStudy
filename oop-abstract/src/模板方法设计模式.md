# 模板方法设计模式全面解析

模板方法模式(Template Method Pattern)是行为型设计模式之一，它定义了一个算法的骨架，将某些步骤延迟到子类中实现，使得子类可以不改变算法结构的情况下重新定义算法的某些特定步骤。

## 一、模式定义

### 1. 核心概念

- **模板方法**：定义在抽象类中的方法，给出算法框架
- **基本方法**：由模板方法调用的具体步骤
    - **抽象方法**：必须由子类实现
    - **钩子方法**：可选由子类实现（提供默认实现）

### 2. 官方定义

> 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

## 二、模式结构

### 1. UML类图

```
+---------------------+       +---------------------+
|    AbstractClass    |       |     ConcreteClass   |
+---------------------+       +---------------------+
| +templateMethod()   |<------| +primitiveOperation1()|
| +primitiveOperation1() {a} | | +primitiveOperation2()|
| +primitiveOperation2() {a} | +---------------------+
| +hookMethod() { }          |
+---------------------+
```

注：{a}表示abstract

### 2. 角色说明

- **AbstractClass（抽象类）**：
    - 定义模板方法和基本方法
    - 模板方法一般设为final防止子类修改
- **ConcreteClass（具体子类）**：
    - 实现抽象类中的抽象方法
    - 可选择性覆盖钩子方法

## 三、代码实现

### 1. 基础实现示例

```java
// 抽象类定义模板
abstract class DataProcessor {
    // 模板方法（final防止子类修改算法结构）
    public final void process() {
        readData();
        processData();
        writeData();
        if (needValidate()) {
            validate();
        }
    }
    
    // 抽象方法（必须由子类实现）
    protected abstract void processData();
    
    // 具体方法（通用实现）
    protected void readData() {
        System.out.println("读取数据...");
    }
    
    protected void writeData() {
        System.out.println("写入结果...");
    }
    
    // 钩子方法（可选实现）
    protected boolean needValidate() {
        return false;
    }
    
    protected void validate() {
        System.out.println("验证数据...");
    }
}

// 具体实现类
class CsvDataProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("处理CSV数据...");
    }
    
    @Override
    protected boolean needValidate() {
        return true;
    }
}

class XmlDataProcessor extends DataProcessor {
    @Override
    protected void processData() {
        System.out.println("处理XML数据...");
    }
}
```

### 2. 客户端调用

```java
public class Client {
    public static void main(String[] args) {
        DataProcessor processor = new CsvDataProcessor();
        processor.process();
        
        System.out.println("----------");
        
        processor = new XmlDataProcessor();
        processor.process();
    }
}
```

## 四、模式特点

### 1. 优点

- **封装不变部分**：将不变行为搬移到超类
- **扩展可变部分**：通过子类扩展可变行为
- **代码复用**：提取公共代码到父类
- **反向控制**：父类调用子类操作（好莱坞原则）

### 2. 缺点

- **增加系统复杂度**：每增加一个实现需要新增子类
- **继承的局限性**：Java单继承限制灵活性

## 五、应用场景

### 1. 典型应用场景

- 多个类有相似算法，但某些步骤不同
- 需要控制子类扩展点的情况
- 框架设计（如Spring的JdbcTemplate）

### 2. Java标准库应用

- `java.util.AbstractList`
- `java.io.InputStream`/`OutputStream`
- `javax.servlet.http.HttpServlet`

## 六、高级应用技巧

### 1. 钩子方法优化

```java
abstract class Game {
    final void play() {
        initialize();
        startPlay();
        endPlay();
        displayScore();
    }
    
    // 钩子方法提供默认实现
    void displayScore() {
        System.out.println("显示基础分数");
    }
    // ...其他方法
}

class Football extends Game {
    @Override
    void displayScore() {
        System.out.println("显示足球比分");
    }
}
```

### 2. 模板方法模式与策略模式结合

```java
abstract class PaymentProcessor {
    private ValidationStrategy validationStrategy;
    
    final void processPayment() {
        validate();
        process();
        notifyUser();
    }
    
    void validate() {
        if (validationStrategy != null) {
            validationStrategy.validate();
        }
    }
    // ...其他方法
}

interface ValidationStrategy {
    void validate();
}
```

## 七、最佳实践

1. **模板方法设计**：
    - 将不变行为移到父类
    - 识别变化点作为抽象方法
    - 提供合理的钩子方法

2. **命名规范**：
    - 模板方法通常命名为`doXXX()`或`processXXX()`
    - 基本方法使用`protected`修饰

3. **文档要求**：
    - 明确说明哪些方法必须实现
    - 说明钩子方法的调用时机

4. **与工厂方法区别**：
    - 工厂方法：创建对象
    - 模板方法：定义算法流程

## 八、常见面试问题

1. **模板方法模式与策略模式的区别？**
    - 模板方法：基于继承，控制算法流程
    - 策略模式：基于组合，封装算法族

2. **为什么模板方法要设为final？**
    - 防止子类改变算法骨架
    - 确保算法流程不被破坏

3. **钩子方法的作用是什么？**
    - 提供扩展点但不强制实现
    - 让子类能够影响模板方法的行为

4. **Spring框架中哪些地方使用了模板方法？**
    - JdbcTemplate
    - HibernateTemplate
    - TransactionTemplate

模板方法模式体现了"好莱坞原则"（"不要调用我们，我们会调用你"），是框架设计中常用的模式，合理使用可以提高代码的复用性和扩展性。