# Java子类构造器知识点全面总结

## 一、子类构造器的基本特性

1. **继承关系中的构造器特点**
    - 构造器**不会**被继承
    - 每个类都必须有自己的构造器
    - 子类构造器必须直接或间接调用父类构造器

2. **默认构造器规则**
    - 如果类中没有显式定义构造器，编译器会自动提供无参构造器
    - 如果父类只有带参构造器，子类必须显式调用父类构造器

## 二、构造器调用机制

### 1. super关键字调用父类构造器
- 必须是子类构造器的**第一条语句**
- 不显式调用时，编译器会自动插入`super()`

```java
class Parent {
    Parent(int x) { System.out.println("Parent"); }
}

class Child extends Parent {
    Child() {
        super(10); // 必须显式调用
        System.out.println("Child");
    }
}
```

### 2. this关键字调用同类构造器
- 也必须是构造器的第一条语句
- 不能与super()同时使用

```java
class Example {
    Example(int x) { /*...*/ }
    Example() {
        this(10); // 调用同类另一个构造器
    }
}
```

## 三、构造器执行顺序

1. **完整初始化顺序**：
   ```
   父类静态代码块 → 子类静态代码块 → 
   父类实例代码块 → 父类构造器 → 
   子类实例代码块 → 子类构造器
   ```

2. **示例说明**：
```java
class Parent {
    static { System.out.println("Parent静态块"); }
    { System.out.println("Parent实例块"); }
    Parent() { System.out.println("Parent构造器"); }
}

class Child extends Parent {
    static { System.out.println("Child静态块"); }
    { System.out.println("Child实例块"); }
    Child() { 
        super(); // 隐含的
        System.out.println("Child构造器"); 
    }
}
/* 输出顺序：
Parent静态块
Child静态块  
Parent实例块
Parent构造器
Child实例块
Child构造器
*/
```

## 四、特殊情况的处理

1. **父类只有带参构造器**
    - 子类必须显式调用父类构造器
    - 不能依赖默认的super()

```java
class Parent {
    Parent(int x) {}
}

class Child extends Parent {
    Child() {
        super(10); // 必须提供参数
    }
}
```

2. **final字段初始化**
    - final字段必须在构造器结束前初始化
    - 可以在声明时、实例代码块或构造器中初始化

```java
class Example {
    final int x;
    { x = 10; } // 实例代码块初始化
    final int y = 20; // 声明时初始化
    final int z;
    Example() { z = 30; } // 构造器初始化
}
```

## 五、构造器与继承的重要规则

1. **不可继承性**
    - 子类不能继承父类构造器
    - 不能重写(override)父类构造器

2. **访问权限**
    - 子类构造器的访问修饰符可以比父类更宽松
    - 但不能比父类更严格

3. **异常声明**
    - 子类构造器可以声明比父类构造器更少的异常
    - 但不能声明更多或更宽泛的异常

## 六、最佳实践建议

1. **链式调用原则**
    - 保持构造器调用链清晰
    - 避免构造器中包含复杂逻辑

2. **防御性编程**
    - 在构造器中验证参数有效性
    - 避免在构造器中调用可被重写的方法

```java
class Parent {
    Parent() {
        checkState(); // 危险！如果被重写
    }
    void checkState() { /*...*/ }
}

class Child extends Parent {
    @Override void checkState() {
        // 此时Child尚未完全初始化
    }
}
```

3. **Builder模式替代**
    - 对于参数较多的类，考虑使用Builder模式

```java
class Complex {
    private final int a, b, c;
    
    private Complex(Builder b) {
        this.a = b.a;
        this.b = b.b;
        this.c = b.c;
    }
    
    static class Builder {
        private int a, b, c;
        Builder a(int a) { this.a = a; return this; }
        // 其他setter...
        Complex build() { return new Complex(this); }
    }
}
```

## 七、常见面试问题

1. **为什么构造器不能被继承？**
    - 构造器不是类的成员方法
    - 构造器名必须与类名相同，子类名与父类名不同

2. **为什么super()必须是第一句？**
    - 确保父类先于子类初始化
    - 避免父类状态未初始化时被子类访问

3. **如何防止构造器被外部调用？**
    - 使用private修饰构造器（用于单例模式等）
   ```java
   class Singleton {
       private Singleton() {}
       public static Singleton getInstance() { /*...*/ }
   }
   ```

掌握这些子类构造器的知识点，能够帮助你在Java面向对象编程中正确实现类的初始化逻辑，构建健壮的类层次结构。