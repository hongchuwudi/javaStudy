# Java方法重写(Override)全面总结

方法重写是Java面向对象编程中多态性的重要体现，以下是关于方法重写的所有关键知识点：

## 一、基本概念
- **定义**：子类重新定义父类中已有的方法
- **目的**：实现多态，改变或扩展父类方法的行为
- **注解**：建议使用`@Override`注解（编译器会检查是否真正重写）

## 二、方法重写的核心规则（"两同两小一大"原则）

### 1. 方法签名相同
- **方法名**必须完全相同
- **参数列表**必须完全相同（参数类型、数量、顺序）

### 2. 返回值类型兼容
- 基本类型：必须完全相同
- 引用类型：可以是父类方法返回值类型的子类（协变返回类型）

```java
class Parent {
    Object create() { return new Object(); }
}

class Child extends Parent {
    @Override
    String create() { return "String"; } // 合法，String是Object的子类
}
```

### 3. 异常抛出限制
- 重写方法抛出的异常必须与父类方法相同，或是其子类
- 不能抛出比父类方法更多的检查型异常(checked exception)

```java
class Parent {
    void process() throws IOException {}
}

class Child extends Parent {
    @Override
    void process() throws FileNotFoundException {} // 合法，FileNotFoundException是IOException的子类
}
```

### 4. 访问权限扩大
- 重写方法的访问权限必须**大于或等于**父类方法
- 权限顺序：`private` < 默认(包私有) < `protected` < `public`

```java
class Parent {
    protected void show() {}
}

class Child extends Parent {
    @Override
    public void show() {} // 合法，权限扩大
    // @Override
    // void show() {}     // 非法，权限缩小
}
```

## 三、不能重写的情况

### 1. 私有方法
- 父类的`private`方法对子类不可见，不能重写
- 子类中定义同名方法实际上是**新方法**，不是重写

```java
class Parent {
    private void secret() {}
}

class Child extends Parent {
    void secret() {} // 这是新方法，不是重写
}
```

### 2. 静态方法
- 静态方法属于类，不存在"重写"概念
- 子类中定义同名静态方法称为**隐藏(hiding)**

```java
class Parent {
    static void print() { System.out.println("Parent"); }
}

class Child extends Parent {
    static void print() { System.out.println("Child"); } // 方法隐藏
}
```

### 3. final方法
- 被`final`修饰的方法不能重写

```java
class Parent {
    final void cannotOverride() {}
}

class Child extends Parent {
    // void cannotOverride() {} // 编译错误
}
```

### 4. 构造方法
- 构造方法不能继承，因此也不能重写

## 四、特殊注意事项

### 1. 静态方法 vs 实例方法
- 父类静态方法不能被子类实例方法"重写"
- 父类实例方法不能被子类静态方法"重写"

```java
class Parent {
    static void staticMethod() {}
    void instanceMethod() {}
}

class Child extends Parent {
    // void staticMethod() {} // 非法
    // static void instanceMethod() {} // 非法
}
```

### 2. 同步修饰符(synchronized)
- `synchronized`修饰符不影响重写
- 子类方法可以自由添加或移除`synchronized`

```java
class Parent {
    void normalMethod() {}
}

class Child extends Parent {
    @Override
    synchronized void normalMethod() {} // 合法
}
```

### 3. 严格浮点(strictfp)
- `strictfp`修饰符不影响重写

## 五、方法重写 vs 方法重载

| 特性         | 方法重写(Override)                  | 方法重载(Overload)                |
|--------------|-------------------------------------|-----------------------------------|
| **作用范围**  | 父子类之间                          | 同一个类中                        |
| **方法签名**  | 必须相同                            | 必须不同（参数列表）              |
| **返回类型**  | 必须兼容                            | 可以不同                          |
| **异常抛出**  | 不能扩大                            | 可以不同                          |
| **访问权限**  | 不能缩小                            | 可以不同                          |
| **多态性**    | 运行时多态                          | 编译时多态                        |

## 六、最佳实践

1. **始终使用@Override注解**
    - 让编译器帮助检查是否真正符合重写规则
    - 提高代码可读性

2. **谨慎设计可重写方法**
    - 明确哪些方法应该允许子类重写
    - 对不应重写的方法使用final修饰

3. **遵守Liskov替换原则**
    - 子类重写方法不应改变父类方法的契约
    - 重写方法应该保持与父类方法相同的行为语义

4. **文档化可重写方法**
    - 使用Javadoc明确说明方法的预期行为和重写要求

```java
/**
 * 执行处理操作，子类可以重写此方法改变处理逻辑
 * @throws IOException 当输入输出异常时抛出
 */
protected void process() throws IOException {
    // 默认实现
}
```

理解并正确使用方法重写机制，可以创建出更加灵活、可扩展的面向对象Java程序。